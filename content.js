const oneMinuteMilliseconds = 60e3;
const pageDomain = location.hostname;
const page = document.documentElement

    ;
(async function main() {
    const pendingOptions = loadOptions()

    if (await isTrustedSite()) {
        return debugLog(`This site is trusted, so no warning.`) // maybe set the icon to a neutral or safe-looking color, rather than red?
    }

    const firstVisitTime = await getResponse({ firstVisitTimeFor: pageDomain })
    const haveVisitedBeforeVeryRecently =
        firstVisitTime !== "null"
        &&
        ((new Date().valueOf() - new Date(firstVisitTime).valueOf()) > oneMinuteMilliseconds)

    if (haveVisitedBeforeVeryRecently) {
        return debugLog(`This site's most recent visit is not in the very recent past, so there's no need for a warning`)
    }

    const warningText = `You have not visited this ${isEmbeddedPage() ? `embedded page (${pageDomain})` : `site`} before or first visited it very recently, according to your browser history. Be aware of phishing attempts.`

    const {
        warnOnVisit,
        warnOnInput,
    } = await pendingOptions

    if (warnOnVisit) {
        displayWarning(warningText)
    }

    if (warnOnInput) {
        page.addEventListener(
            'input',
            () => displayWarning(`It looks like you're entering text. ` + warningText),
            { once: true },
        )
    }
})()

async function loadOptions() {
    return new Promise((resolve, reject) => chrome.storage.sync.get(results => {
        if (!results) {
            return reject(chrome.runtime.lastError)
        }

        resolve(
            Object.keys(results).filter(key => key.startsWith('option#')).reduce((options, key) => {
                options[key.replace(/^option#/, '')] = results[key]

                return options
            }, {})
        )
    }))
}

async function getResponse(message) {
    debugLog(`sending request: ${JSON.stringify(message)}`)

    return new Promise((resolve, reject) =>
        chrome.runtime.sendMessage(message, function (response) {
            if (!response) {
                debugLog(`no response, checking errors: ${JSON.stringify(chrome.runtime.lastError)}`)
                reject(chrome.runtime.lastError)
            }

            debugLog(`got response: ${response}`)
            resolve(response)
        })
    )
}

/**
 * @param {string} message
 */
function displayWarning(message) {
    const warningDiv = document.createElement('div')
    const warningText = document.createElement('p')
    const footerText = document.createElement('p')
    const closeWarning = () => page.removeChild(warningDiv)

    warningDiv.setAttribute('style', `
        all: unset;
        position: fixed;
        z-index: 2147483647;
        background-color: #cc3300;
        color: white;
        font-family: sans-serif;
        margin: 1em;
        padding: 1.5em;
        box-shadow: 0 0 3em 0 #4a4a4a;
    `)

    warningText.innerHTML = message
    warningText.setAttribute('style', `
        all: unset;
        font-weight: bold;
        font-size: 1.4em;
    `)
    warningDiv.appendChild(warningText)

    warningDiv.appendChild(document.createElement('br'))
    warningDiv.appendChild(button('close', closeWarning))
    warningDiv.appendChild(button('report phishing', () => window.open('https://www.phishing.org/how-to-report-phishing', '_blank')))
    warningDiv.appendChild(button('prevent future warnings for this domain', () => {
        closeWarning()
        trustSite()
    }))

    footerText.innerHTML = 'This message was generated by the New Site Warning browser extension.'
    footerText.setAttribute('style', `
        all: unset;
        font-weight: lighter;
        font-size: 0.8em;
    `)
    warningDiv.appendChild(document.createElement('br'))
    warningDiv.appendChild(footerText)

    page.insertAdjacentElement('afterbegin', warningDiv)
}

/**
 * @param {string} text
 * @param {HTMLButtonElement['onclick']} onClick
 * @return {HTMLButtonElement}
 */
function button(text, onClick = () => { }) {
    const element = document.createElement('button')
    const style = `
        all: unset;
        padding: 0.5em;
        margin-top: 1em;
        margin-bottom: 1em;
        margin-right: 1em;
        border: 0.2em solid white;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 0.5em 0;
    `

    element.innerHTML = text
    element.setAttribute('style', style)
    element.addEventListener('click', onClick)
    element.addEventListener('mouseenter', () => element.setAttribute('style', style + 'box-shadow: 0 0 1.5em 0;'))
    element.addEventListener('mouseleave', () => element.setAttribute('style', style))

    return element
}

/**
 * From https://stackoverflow.com/a/326076/3246022
 *
 * @return {boolean}
 */
function isEmbeddedPage() {
    try {
        return window.self !== window.top;
    } catch (e) {
        return true;
    }
}

/**
 * Causes the current site to be permanently trusted.
 *
 * This uses synchronized chrome storage.
 * - docs: https://developer.chrome.com/extensions/storage
 * - quotas: https://developer.chrome.com/extensions/storage#property-sync
 */
async function trustSite() {
    return new Promise((resolve, reject) => {
        chrome.storage.sync.set({ [pageDomain]: 1 }, async () => {
            // errors will cause this to "fail immediately" and put the error in `runtime.lastError`, but it's not clear how to tell whether the `lastError` was a result of this failing, or how to tell that this failed "immediately", so there's no error handling for now. I'd like to add some in the future if there's a good way. So this is how error handling works, even though it seems kind of roundabout.
            if (!(await isTrustedSite())) {
                return reject(new Error(`Failed to trust this site: ${chrome.runtime.lastError ? chrome.runtime.lastError.message : `unknown error`}`))
            }


            resolve()
        })
    })
}

/**
 * @return {Promise<boolean>}
 */
async function isTrustedSite() {
    return new Promise((resolve, reject) => {
        chrome.storage.sync.get(pageDomain, items => {
            if (!items) {
                return reject(new Error(`Failed to determine whether this is a trusted site: ${chrome.runtime.lastError ? chrome.runtime.lastError.message : `unknown error`}`))
            }

            if (!Reflect.has(items, pageDomain)) {
                return resolve(false)
            }

            resolve(Boolean(items[pageDomain]))
        })
    })
}

function debugLog(...messages) {
    console.debug(`[New Site Warning browser extension running on ${location.hostname}] -`, ...messages)
}
